-- [Ⅶ] DDL, DCL, DML
-- DDL
-- 1. 테이블 생성(CREATE TABLE)
CREATE TABLE BOOK(
    BOOKID NUMBER(4),
    BOOKNAME VARCHAR2(300),
    PUBLISHER VARCHAR2(300),
    RDATE DATE,
    PRICE NUMBER(8),
    PRIMARY KEY(BOOKID));
    
DESC BOOK;
DROP TABLE BOOK;

CREATE TABLE BOOK (
    BOOKID NUMBER(4) PRIMARY KEY,
    BOOKNAME VARCHAR(20),
    PUBLISHER VARCHAR2(20),
    RDATE DATE,
    PRICE NUMBER(8) );

SELECT ROWNUM, EMPNO, ENAME FROM EMP;  -- ROWNUM : 테이블에서 읽어들인 논리적 순서
SELECT ROWNUM, EMPNO, ENAME FROM EMP WHERE DEPTNO = 20 ORDER BY ENAME;

CREATE TABLE EMP01 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7, 2) );

CREATE TABLE DEPT01 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR(13) );

-- 서브쿼리를 이용한 테이블 생성
CREATE TABLE EMP02 AS
    SELECT * FROM EMP;  -- 서브쿼리 결과만 EMP02테이블 생성 후 들어감 (제약조건 미포함)
SELECT * FROM EMP02;

-- ex. EMP03 : EMPNO, ENAME, DEPTNO만 추출한 데이터로 테이블 생성
CREATE TABLE EMP03
    AS SELECT EMPNO, ENAME, DEPTNO FROM EMP;
SELECT * FROM EMP03;

-- ex.EMP04 : 10번 부서인 데이터로 테이블 생성
CREATE TABLE EMP04
    AS SELECT * FROM EMP WHERE DEPTNO = 10;
SELECT * FROM EMP04;

-- ex. EMP05 : EMP 테이블 구조만 추출
CREATE TABLE EMP05
    AS SELECT * FROM EMP WHERE 1=0;
SELECT * FROM EMP05;

-- 2. 테이블 구조 변경(ALTER TABLE)
-- ALTER TABLE 테이블명 ADD / MODIFY / DROP
-- (1) 필드 추가(ADD) : 추가된 필의 데이터는 NULL
SELECT * FROM EMP03;
ALTER TABLE EMP03 ADD (JOB VARCHAR2(20), SAL NUMBER(7, 2));
SELECT * FROM EMP03;
ALTER TABLE EMP03 ADD (COMM NUMBER(7, 2));

-- (2) 필드 수정(MODIFY)
SELECT * FROM EMP03;
ALTER TABLE EMP03 MODIFY (EMPNO VARCHAR2(4));  -- 데이터가 있는 상태에서는 형변환 불가
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(3));   -- 데이터가 손살이 되는 수정은 불가
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(5));
ALTER TABLE EMP03 MODIFY (ENAME NUMBER(4));
SELECT MAX(LENGTH(ENAME)) FROM EMP;
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(30));
DESC EMP03;
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(6));
ALTER TABLE EMP03 MODIFY (JOB VARCHAR(2));
ALTER TABLE EMP03 MODIFY (JOB NUMBER(4));

-- (3) 필드 삭제(DROP TABLE)
ALTER TABLE EMP03 DROP COLUMN JOB;
SELECT * FROM EMP03;

-- 논리적으로 특정 필드를 접근 못하도록 설정
ALTER TABLE EMP03 SET UNUSED (DEPTNO);
SELECT * FROM EMP03;

-- 논리적으로 접근 불가했던 필드를 물리적으로 삭제
ALTER TABLE EMP03 DROP UNUSED COLUMNS;
SELECT * FROM EMP03;

-- 3. 테이블 삭제 (DROP TABLE)
DROP TABLE EMP01;
SELECT * FROM TAB;
DROP TABLE DEPT;  -- 다른테이블에서 참조하고 있을 경우 삭제 불가

-- 4. 테이블의 모든 행을 제거 (TRUNCATE)
SELECT * FROM EMP02;
TRUNCATE TABLE EMP02;

-- 5. 테이블명 변경(RENAME)
SELECT * FROM EMP02;
RENAME EMP02 TO EMP2;
SELECT * FROM EMP2;

-- 6. 데이터 딕셔너리(접근 불가) VS 데이터 딕셔너리 뷰(사용자 접근용) 

-- 데이터 딕셔너리 뷰 종류
-- (1) USER_XXX : 현 계정이 소유하고 있는 객체(테이블, 인덱스, 제약조건, 뷰 등등)
-- ex. USER_TABLES, USER_INDEXES, USER_CONSTRAINTS, USER_VIEWS
SELECT * FROM USER_TABLES;  --  내 계정이 소유한 테이블 객체 정보
SELECT * FROM USER_INDEXES; -- 내 계정이 소유한 인덱스 정보
SELECT * FROM USER_CONSTRAINTS; -- 내 계정이 소유한 제약조건들
SELECT * FROM USER_VIEWS;   -- 내 계정이 소유한 뷰 정보

-- (2) ALL_XXX : 현 계정이 접근 가능한 객체(테이블, 인덱스, 제약조건, 뷰 등등)
-- ex. ALL_TABLES, ALL_INDEXES, ALL_CONSTRAINTS, ALL_VIEWS
SELECT * FROM ALL_TABLES;
SELECT * FROM ALL_INDEXES;
SELECT * FROM ALL_CONSTRAINTS;
SELECT * FROM ALL_VIEWS;

-- (3) DBA_XXX : DBA권한이지만 접근가능. DBMS의 모든 객체
-- ex. DBA_TABLES, DBA_INDEXES, DBA_CONSTRAINTS, DBA_VIEWS
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_INDEXES;
SELECT * FROM DBA_CONSTRAINTS;
SELECT * FROM DBA_VIEWS;

-- DCL
CREATE USER SCOTT2 IDENTIFIED BY 1234;  -- 계정생성
GRANT CREATE SESSION TO SCOTT2;  -- 세션(로그인)권한 부여
GRANT ALL ON EMP TO SCOTT2;     -- EMP 테이블에 대한 모든 권한(검색, 추가, 수정, 삭제) 부여
GRANT ALL ON DEPT TO SCOTT2;
REVOKE ALL ON EMP FROM SCOTT2;  -- EMP 테이블에 대한 모든권한 박탈
REVOKE ALL ON DEPT FROM SCOTT2;
DROP USER SCOTT2 CASCADE; -- 계정 삭제
SHOW USER;

-- DML
-- 1. INSERT INTO 테이블명 VALUES(값1, 값2, 값3, ...);
--    INSERT INTO 테이블명 (필드명1, 필드명2, 필드명3, ...) VALUES(값1, 값2, 값3, ...);
SELECT * FROM DEPT01;
INSERT INTO DEPT01 VALUES (50, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (60, 'IT', 'SEOUL');
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (70, 'OPERATION'); -- 묵시적 NULL 추가
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (80, 'HR', NULL);  -- 명시적 NULL 추가
-- 서브쿼리를 이용한 INSERT
INSERT INTO DEPT01 SELECT * FROM DEPT;
-- 트랜잭션 명령어 (DML 명령어만)
COMMIT;

-- 2. UPDATE 테이블명 SET 필드명1 = 값1[, 필드명2 = 값2, ...] [WHERE 조건];
CREATE TABLE EMP01 AS SELECT * FROM EMP;
UPDATE EMP01 SET DEPTNO = 30;
SELECT * FROM EMP01;
UPDATE EMP01 SET SAL = SAL*1.1;
ROLLBACK;
UPDATE EMP01 SET HIREDATE = SYSDATE, DEPTNO = 30 WHERE DEPTNO = 10;
UPDATE EMP01 SET SAL = SAL*1.1 WHERE SAL >= 3000;

-- 'DALLAS'에 근무하는 직원의 급여를 1000씩 인상
UPDATE EMP01 SET SAL = SAL + 1000 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');

UPDATE EMP01 SET DEPTNO = 20, JOB = 'MANAGER', SAL = SAL + 500, COMM = NVL(COMM, 0) + 500,
    MGR = (SELECT EMPNO FROM EMP01 WHERE ENAME = 'KING') WHERE ENAME = 'SCOTT';

UPDATE DEPT01 SET LOC = (SELECT LOC FROM DEPT WHERE DEPTNO = 60) WHERE DEPTNO >= 20;
SELECT * FROM DEPT01;
COMMIT;
UPDATE EMP01 SET SAL = (SELECT SAL FROM EMP01 WHERE ENAME = 'KING'), HIREDATE = (SELECT HIREDATE FROM EMP01 WHERE ENAME = 'KING')
    WHERE ENAME != 'KING';
UPDATE EMP01 SET (SAL, HIREDATE) = (SELECT SAL, HIREDATE FROM EMP01 WHERE ENAME = 'KING');
SELECT * FROM EMP01;
ROLLBACK;

UPDATE DEPT01 SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT01 WHERE DEPTNO = 40)
    WHERE DEPTNO = 20;
COMMIT;

-- 3. DELETE FROM 테이블명 [WHERE 조건];

SELECT * FROM EMP01;
DELETE FROM EMP01;
ROLLBACK;

DELETE FROM EMP01 WHERE ENAME = 'FORD';

DELETE FROM EMP01 WHERE DEPTNO = 30;

DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT01 WHERE DNAME = 'RESEARCH');

DELETE FROM SAM01 WHERE JOB IS NULL;
SELECT * FROM SAM01;
ROLLBACK;

DELETE FROM SAM01 WHERE ENAME = 'ORANGE';

-- 제약조건 : 부적합한 데이터가 테이블에 삽입, 수정되는 것을 방지하기 위해
SELECT * FROM EMP;
INSERT INTO EMP VALUES ( 7369, '홍', NULL, NULL, SYSDATE, NULL, NULL, 40);
UPDATE EMP SET EMPNO = 7369 WHERE ENAME = 'ALLEN';

-- (1) PRIMARY KEY(프로젝트 시 꼭 사용 /★많이씀★)  : 유일하게 테이블의 각 행을 식별. NOT NULL
INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (7369, '홍', 40); -- 중복된 사번 입력 불가;

-- (2) NOT NULL : NULL 값만 포함하지 않음

-- (3) UNIQUE : 모든 행에 대해 유일해야 함. NULL값을 허용 (여러행 입력 가능)

-- (4) FOREIGNT KEY (프로젝트 시 꼭 사용 /★많이씀★) : 테이블의 열은 다른 테이블의 열을 참조 (ex. EMP테이블의 DEPTNO는 DEPT 테이블의 DEPTNOM를 참조)
-- 비식별관계 : 부모테이블의 주키가 자식테이블의 일반속성에 속한 필드로 관계 (eXERD에서 빨간점선화살표)
-- 식별관계 : 부모테이블의 주키가 자식테이블의 주키에 속한 필드로 관계 (eXERD에서 초록점선화살표)


INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (1111, '홍', 90); -- DEPT 테이블에 DEPTNO값이 없어서 에러

-- (5)CHECK(조건) : 해동 조건이 만족 (NULL값 허용)

-- DEFAULT(★많이씀★) : 기본값 설정(해당 열의 데이터 입력값이 없으면 NULL이 들어감)
INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (1111, '홍', 90);

DROP TABLE DEPT1;
CREATE TABLE DEPT1 (
    DEPTNO NUMBER(4) PRIMARY KEY,
    DNAME VARCHAR2(14) UNIQUE,
    LOC VARCHAR2(13) NOT NULL );
    
DROP TABLE EMP1;
CREATE TABLE EMP1 (
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7, 2) CHECK (SAL > 0),
    COMM NUMBER(7, 2),
    DEPTNO NUMBER(2) REFERENCES DEPT1(DEPTNO) );

DROP TABLE DEPT1 CASCADE CONSTRAINTS; -- 참조하는 테이블이 있어도 무시하고 DROP (비추)



CREATE TABLE DEPT1 (
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13) NOT NULL,
    PRIMARY KEY (DEPTNO),
    UNIQUE (DNAME) );
    
CREATE TABLE EMP1 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7, 2),
    COMM NUMBER(7, 2),
    DEPTNO NUMBER(2),
    PRIMARY KEY (EMPNO),
    CHECK (SAL > 0),
    FOREIGN KEY (DEPTNO) REFERENCES DEPT1(DEPTNO) );

SELECT * FROM EMP1;
SELECT * FROM DEPT1;
INSERT INTO DEPT1 SELECT * FROM DEPT;
INSERT INTO DEPT1 VALUES (40, 'IT', 'SEOUL');  -- EMPNO PK 제약조건
INSERT INTO DEPT1 VALUES (50, 'SALES', 'SEOUL');  -- DNAME UNIQUE 제약조건
INSERT INTO DEPT1 VALUES (50, 'IT', NULL);  -- LOC NOT NULL 제약조건
INSERT INTO EMP1 (EMPNO, ENAME, DEPTNO)
    VALUES (1111, '홍', 10);
SELECT * FROM EMP1;
INSERT INTO EMP1 (EMPNO, ENAME, DEPTNO)
    VALUES (1111, '김', 10); -- EMPNO PK 제약조건
INSERT INTO EMP1 (EMPNO, DEPTNO)
    VALUES (1112, 20); -- ENAME NOT NULL 제약조건
INSERT INTO EMP1 (EMPNO, ENAME, SAL)
    VALUES (1112, '박', -1); -- SAL > 0 (CHECK) 제약조건
INSERT INTO EMP1 VALUES (1112, '윤', NULL, NULL, TO_DATE('95/01/01', 'YY/MM/DD'), 900, NULL, 99); -- DEPTNOFK 제약조건















